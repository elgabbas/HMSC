#' @title sampleMCMC
#'
#' @description Samples the posterior with block-conditional Gibbs MCMC sampler
#'
#' @param hM a fitted \code{Hmsc} model object
#' @param samples the number of MCMC samples to be obtained in each chain
#' @param transient the number of MCMC steps that are executed before starting recording posterior samples
#' @param thin the number of MCMC steps between each recording of samples from the posterior
#' @param initPar a named list of parameter values used for
#'     initialization of MCMC states, or alternatively text
#'     \code{"fixed effects"} to use linear Maximum Likelihood model
#'     instead of randomizing from prior; the \code{"fixed effects"}
#'     can shorten the transient phase of sampling, but will
#'     initialize all chains to the same starting values
#' @param verbose the interval between MCMC steps printed to the console (default is an interval that prints ca. 50 reports)
#' @param adaptNf a vector of length \eqn{n_r} with number of MCMC steps at which the adaptation of the
#' number of latent factors is conducted
#' @param nChains total number of independent MCMC chains to be run
#' @param indChains vector with indexes of which chains shall be run
#' @param nParallel number of parallel processes by which the chains are executed
#' @param dataParList a named list with pre-computed \code{phyloPar}, \code{rLPar} parameters
#' @param updater a named list, specifying which conditional updaters should be ommitted
#' @param fromPrior whether prior (TRUE) or posterior (FALSE) is to be sampled
#' @param alignPost boolean flag indicating whether the posterior of each chains should be aligned
#'
#' @return An \code{Hmsc}-class object with chains of posterior samples added to the \code{postList} field
#'
#' @details The exact number of samples to be recorded in order to get a proper estimate of the full posterior with
#'   Gibbs MCMC algorithms, as well as the required thinning and cut-off of transient is very problem-specific and
#'   depends both on the model structure and the data itself. Therefore, in general it is very challenging to a priori
#'   provide an informed recommendation on what values should be used for a particular problem. A common recommended
#'   strategy involves executing the posterior sampling with MCMC with some guess of the values for these arguments,
#'   checking the properties of the obtained samples (primarily potential scale reduction factor and effective sample
#'   size), and adjusting the guess accordingly.
#'
#'   The value of 1 for \code{thin} argument means that at each MCMC step after the transient a sample is recorded.
#'
#'   Typically, the value of \code{nParallel} equal to \code{nChains} leads to most efficient usage of available
#'   parallelization capacities. However, this may be not the case if R is configured with multi-tread linear
#'   algebra libraries. For debug and test purposes, the \code{nParallel} should be set to 1, since only in this case a
#'   details of the potentially encountered errors would be available.
#'
#'   The \code{dataParList} argument may be handy for large problems that needs to be refitted multiple times, e.g.
#'   with different prior values. In that case, the data parameters that are precomputed for the Hmsc sampling
#'   scheme may require an undesirably lot of storage space if they are saved for each of the model.
#'   Instead, they could be computed only once and then directly reused, therefore reducing the storing redundancy.
#'
#'   Some of the available conditional updaters partially duplicate each other. In certain cases, the usage of all
#'   of them may lead to suboptimal performance, compared to some subset of those. Then, it is possible to manually
#'   disable some of them, by adding a \code{$UPDATER_NAME=FALSE} pair to the {updater} argument. Another usage of
#'   this argument involves cases when some of the model parameters are known and have to be fixed. However, such
#'   tweaks of the sampling scheme should be done with caution, as if compromized they would lead to erroneuos
#'   results.
#'
#'
#' @seealso \code{\link{Hmsc}}
#'
#' @examples
#' ## you need 1000 or more samples, but that will take too long
#' ## in an example
#' m = sampleMcmc(TD$m, samples=10)
#'
#' \dontrun{
#' ## Record 1000 posterior samples while skipping 1 MCMC step between samples
#' ## from 2 chains after discarding the first 500 MCMC steps
#' m = sampleMcmc(TD$m, samples=1000, transient=500, thin=2, nChains=2, nParallel=1)
#' }
#'
#' @importFrom parallel makeCluster clusterExport clusterEvalQ clusterApplyLB stopCluster
#' @export

sampleMcmc =
    function(hM, samples, transient=0, thin=1, initPar=NULL,
             verbose, adaptNf=rep(transient,hM$nr),
             nChains=1, indChains=NULL, nParallel=1, dataParList=NULL, updater=list(),
             fromPrior = FALSE, alignPost = TRUE)
{
   if (missing(verbose)) {
       if (samples*thin <= 50) # report every sampling
           verbose <- 1
       else                    # report ~50 steps of sampling
           verbose <- samples*thin/50
   }
   verbose <- as.integer(verbose) # truncate to integer
   if(fromPrior)
      nParallel = 1
   force(adaptNf)
   if(is.null(indChains)){
      indChains <- 1:nChains
   }
   if(nParallel > length(indChains)){
      warning('number of cores cannot be greater than the effective number of chains in this run; reducing to match.')
      nParallel <- length(indChains)
   }
   if(any(adaptNf>transient))
      stop('transient parameter should be no less than any element of adaptNf parameter')

   #X1 is the original X matrix (scaled version).
   #X used in computations is modified from X1 by variable selection and dimension reduction.
   X1 = hM$XScaled
   if (hM$ncsel>0){
      if(is.matrix(X1)){
         X2=X1
         X1=list()
         for (j in 1:hM$ns){
            X1[[j]] = X2
         }
      }
   }

   Tr = hM$TrScaled
   Y = hM$YScaled
   distr = hM$distr
   Pi = hM$Pi
   dfPi = hM$dfPi
   C = hM$C
   nr = hM$nr

   mGamma = hM$mGamma
   iUGamma = chol2inv(chol(hM$UGamma))
   V0 = hM$V0
   f0 = hM$f0
   aSigma = hM$aSigma
   bSigma = hM$bSigma
   rhopw = hM$rhopw

   if(is.null(dataParList))
      dataParList = computeDataParameters(hM)
   phyloPar = dataParList$phyloPar
   rLPar = dataParList$rLPar

   hM$postList = vector("list", nChains)
   hM$repList = vector("list", nChains)
   ## save random seed that is used to generate initSeed[s]
   if (!exists(".Random.seed")) # may not exist, so generate
      runif(1)
   hM$randSeed <- .Random.seed
   initSeed = sample.int(.Machine$integer.max, nChains)

   ######## switching of the augmented updaters if the required conditions are not met
   EPS = 1e-6
   updaterWarningFlag = TRUE
   # updater$Gamma2
   if(!identical(updater$Gamma2, FALSE) && any(abs(mGamma) > EPS)){
      updater$Gamma2 = FALSE
      if(updaterWarningFlag)
         message("setting updater$Gamma2=FALSE due to non-zero mGamma")
   }
   if(!identical(updater$Gamma2, FALSE) && any(abs(iUGamma - kronecker(iUGamma[1:hM$nc,1:hM$nc], diag(hM$nt))) > EPS)){
      updater$Gamma2 = FALSE
      if(updaterWarningFlag)
         message("setting updater$Gamma2=FALSE due to non-kronecker structure of UGamma matrix")
   }
   if(!identical(updater$Gamma2, FALSE) && (!is.null(C))){
      updater$Gamma2 = FALSE
      if(updaterWarningFlag)
         message("setting updater$Gamma2=FALSE due to specified phylogeny matrix")
   }
   # updater$GammaEta
   if(!identical(updater$GammaEta, FALSE) && any(abs(mGamma) > EPS)){
      updater$GammaEta = FALSE
      if(updaterWarningFlag)
         message("setting updater$GammaEta=FALSE due to non-zero mGamma")
   }
   if(!identical(updater$GammaEta, FALSE) && hM$nr==0){
      updater$GammaEta = FALSE
      if(updaterWarningFlag)
         message("setting updater$GammaEta=FALSE due to absence of random effects included to the model")
   }
   # NNGP & GPP models will give an error in updateGammaEta()
   if (!identical(updater$GammaEta, FALSE) &&
       any(sapply(hM$rL,
                  function(s) !is.null(s$spatialMethod) &&
                  s$spatialMethod %in% c("GPP", "NNGP")))) {
       updater$GammaEta = FALSE
       if (updaterWarningFlag)
           message("setting updater$GammaEta=FALSE: not implemented for spatial methods 'GPP' and 'NNGP'")
   }

   ## latentLoadingOrderSwap: as of version 3.0.10 this is still an
   ## experimental feature and we do not advertise it by broadcasting
   ## messages that it is disabled
   if(identical(updater$latentLoadingOrderSwap, NULL)){
      updater$latentLoadingOrderSwap = 0
      if(FALSE && updaterWarningFlag) # do not advertise yet
         message("setting updater$latentLoadingOrderSwap=0 disabling full-conditional swapping of consecutive latent loadings")
   }


   sampleChain = function(chain){
      if(nChains>1)
         cat(sprintf("Computing chain %d\n", chain))
      set.seed(initSeed[chain])
      parList = computeInitialParameters(hM,initPar)

      Gamma = parList$Gamma
      V = parList$V
      iV = chol2inv(chol(V))
      Beta = parList$Beta
      BetaSel = parList$BetaSel
      PsiRRR = parList$PsiRRR
      DeltaRRR = parList$DeltaRRR
      wRRR = parList$wRRR
      sigma = parList$sigma
      iSigma = 1 / sigma
      LambdaTilde = parList$LambdaTilde
      Lambda = parList$Lambda
      Eta = parList$Eta
      Alpha = parList$Alpha
      Psi = parList$Psi
      Delta = parList$Delta
      rho = parList$rho
      Z = parList$Z
      BetaLatent = parList$BetaLatent
      GammaLatent = parList$GammaLatent
      rhoLatent = parList$rhoLatent
      Vartheta = parList$Vartheta
      Varphi = parList$Varphi
      W = parList$W
      TildeU = parList$TildeU

      X1A = X1
      if(hM$ncsel>0){
         for (i in 1:hM$ncsel){
            XSel = hM$XSelect[[i]]
            for (spg in 1:length(XSel$q)){
               if(!BetaSel[[i]][spg]){
                  fsp = which(XSel$spGroup==spg)
                  for (j in fsp){
                     X1A[[j]][,XSel$covGroup]=0
                  }
               }
            }
         }
      }

      X = X1A
      if(hM$ncRRR>0){
         XB=hM$XRRRScaled%*%t(wRRR)
         if(is.matrix(X)){
            X=cbind(X,XB)
         } else {
            for (j in 1:hM$ns){
               X[[j]] = cbind(X[[j]],XB)
            }
         }
      }

      if(!identical(updater$Gamma2, FALSE) && (!is.matrix(X))){
         updater$Gamma2 = FALSE
         if(updaterWarningFlag)
            message("setting updater$Gamma2=FALSE due to X is not a matrix")
      }
      if(!identical(updater$GammaEta, FALSE) && (!is.matrix(X))){
         updater$GammaEta = FALSE
         if(updaterWarningFlag)
            message("setting updater$GammaEta=FALSE due to X is not a matrix")
      }

      postList = vector("list", samples)
      for(iter in seq_len(transient+samples*thin)){

         if(!identical(updater$Gamma2, FALSE)){
            if(length(rho)>1){
               warning('Gamma2 is not yet implemented for vector rho. Set updater$Gamma2=FALSE.')
            }
            Gamma = updateGamma2(Z=Z,Gamma=Gamma,iV=iV,iSigma=iSigma,
               Eta=Eta,Lambda=Lambda, X=X,Pi=Pi,dfPi=dfPi,Tr=Tr,C=C,rL=hM$rL, phyloPar=phyloPar,
               mGamma=mGamma,iUGamma=iUGamma)
         }

         if(!identical(updater$GammaEta, FALSE)){
            if(length(rho)>1){
               warning('updateGammaEta is not yet implemented for vector rho. Set updater$GammaEta=FALSE.')
            }
            GammaEtaList = updateGammaEta(Z=Z,Gamma=Gamma,V=chol2inv(chol(iV)),iV=iV,id=iSigma,
               Eta=Eta,Lambda=Lambda,Alpha=Alpha, X=X,Pi=Pi,dfPi=dfPi,Tr=Tr,rL=hM$rL, rLPar=rLPar,phyloPar=phyloPar,rho=rho,
               mGamma=mGamma,U=hM$UGamma,iU=iUGamma)
            Gamma = GammaEtaList$Gamma
            Eta = GammaEtaList$Eta
         }

         if(!identical(updater$BetaLambda, FALSE)){
            # if(length(rho)>1){
            #    warning('updateBetaLambda is not yet implemented for vector rho. Set updater$BetaLambda=FALSE.')
            # }
            # BetaLambdaList = updateBetaLambda(Y=Y,Z=Z,Gamma=Gamma,iV=iV,
            #    iSigma=iSigma,Eta=Eta,Psi=Psi,Delta=Delta,rho=rho, VC=VC,eC=eC,
            #    X=X,Tr=Tr,Pi=Pi,dfPi=dfPi,C=C,rL=hM$rL, rhopw=rhopw)
            BetaLambdaList = updateBetaLambda(Y=Y,Z=Z,Gamma=Gamma,iV=iV,
                iSigma=iSigma,Eta=Eta,Psi=Psi,Delta=Delta,rho=rho,Vartheta=Vartheta,Varphi=Varphi,
                phyloPar=phyloPar, X=X,Tr=Tr,Pi=Pi,dfPi=dfPi,C=C,rL=hM$rL, rhopw=rhopw)
            Beta = BetaLambdaList$Beta
            Lambda = BetaLambdaList$Lambda
            LambdaTilde = BetaLambdaList$LambdaTilde
         }

         if(!identical(updater$wRRR, FALSE) &&  hM$ncRRR>0){
            wRRRXList = updatewRRR(Z=Z, Beta=Beta, iSigma=iSigma,
                                 Eta=Eta, Lambda=Lambda, X1A=X1A, XRRR=hM$XRRRScaled,
                                 Pi=Pi, dfPi=dfPi,rL = hM$rL, PsiRRR=PsiRRR, DeltaRRR=DeltaRRR)
            wRRR = wRRRXList$wRRR
            X = wRRRXList$X
         }

         if(!identical(updater$BetaSel, FALSE) &&  hM$ncsel>0){
            BetaSelXList = updateBetaSel(Z=Z,XSelect = hM$XSelect, BetaSel=BetaSel,Beta=Beta, iSigma=iSigma,
                                    Lambda=Lambda, Eta=Eta, X1=X1,Pi=Pi,dfPi=dfPi,rL=hM$rL)
            BetaSel = BetaSelXList$BetaSel
            X = BetaSelXList$X
         }

         if(!identical(updater$GammaV, FALSE)){
            GammaVList = updateGammaV(Beta=Beta,Gamma=Gamma,iV=iV,rho=rho,
               phyloPar=phyloPar, Tr=Tr,C=C, mGamma=mGamma,iUGamma=iUGamma,V0=V0,f0=f0,rhopw=rhopw)
            Gamma = GammaVList$Gamma
            iV = GammaVList$iV
         }

         if(!is.null(hM$C) && !identical(updater$Rho, FALSE)){
            rho = updateRho(rho=rho,Beta=Beta,Gamma=Gamma,iV=iV, phyloPar=phyloPar,
               Tr=Tr, rhopw=rhopw,rhoAlphaDP=hM$rhoAlphaDP)
         }

         if(!identical(updater$latentBetaGammaRho, FALSE)){
            latentBetaGammaRhoList = updateLatentBetaGammaRho(GammaLatent=GammaLatent,BetaLatent=BetaLatent,Varphi=Varphi,
                                                              rhoLatent=rhoLatent, Tr=Tr,phyloPar=phyloPar,rL=hM$rL, rhopw=rhopw)
            BetaLatent = latentBetaGammaRhoList$BetaLatent
            GammaLatent = latentBetaGammaRhoList$GammaLatent
            rhoLatent = latentBetaGammaRhoList$rhoLatent
         }

         if(!identical(updater$LambdaContPriors, FALSE)){
            PsiDeltaList = updateLambdaContPriors(LambdaTilde=LambdaTilde,Delta=Delta,Vartheta=Vartheta, rL=hM$rL)
            Psi = PsiDeltaList$Psi
            Delta = PsiDeltaList$Delta
         }
         if(!identical(updater$LambdaDiscPriors, FALSE)){
            LambdaVarphiVarthetaWList = updateLambdaDiscPriors(Z=Z,Beta=Beta,iSigma=iSigma,Eta=Eta,Lambda=Lambda,LambdaTilde=LambdaTilde,Delta=Delta,
                                                  BetaLatent=BetaLatent,Varphi=Varphi,Vartheta=Vartheta,TildeU=TildeU,W=W, X=X,Pi=Pi,rL=hM$rL)
            Lambda = LambdaVarphiVarthetaWList$Lambda
            Varphi = LambdaVarphiVarthetaWList$Varphi
            Vartheta = LambdaVarphiVarthetaWList$Vartheta
            W = LambdaVarphiVarthetaWList$W
         }
         if(!identical(updater$wRRRPriors, FALSE) &&  hM$ncRRR>0){
            PsiDeltaList = updatewRRRPriors(wRRR=wRRR,Delta=DeltaRRR,
                                           nu=hM$nuRRR,a1=hM$a1RRR,
                                           b1=hM$b1RRR,a2=hM$a2RRR,b2=hM$b2RRR)
            PsiRRR = PsiDeltaList$Psi
            DeltaRRR = PsiDeltaList$Delta
         }

         if(!identical(updater$Eta, FALSE))
            Eta = updateEta(Y=Y,Z=Z,Beta=Beta,iSigma=iSigma,Eta=Eta,
               Lambda=Lambda,Alpha=Alpha, rLPar=rLPar, X=X,Pi=Pi,dfPi=dfPi,rL=hM$rL)

         if(!identical(updater$Alpha, FALSE))
            Alpha = updateAlpha(Eta=Eta, rLPar=rLPar, rL=hM$rL)

         if(!identical(updater$InvSigma, FALSE))
            iSigma = updateInvSigma(Y=Y,Z=Z,Beta=Beta,iSigma=iSigma,
               Eta=Eta,Lambda=Lambda, distr=distr,X=X,Pi=Pi,dfPi=dfPi,rL=hM$rL, aSigma=aSigma,bSigma=bSigma)

         if(!identical(updater$Z, FALSE)){
            Z = updateZ(Y=Y,Z=Z,Beta=Beta,iSigma=iSigma,Eta=Eta,Lambda=Lambda, X=X,Pi=Pi,dfPi=dfPi,distr=distr,rL=hM$rL)
         }

         for(r in seq_len(nr)){
            if(iter <= adaptNf[r]){
               listPar = updateNf(eta=Eta[[r]],lambda=Lambda[[r]],alpha=Alpha[[r]],psi=Psi[[r]],delta=Delta[[r]],
                                  rL=hM$rL[[r]], iter=iter)
               Lambda[[r]] = listPar$lambda
               Eta[[r]] = listPar$eta
               Alpha[[r]] = listPar$alpha
               Psi[[r]] = listPar$psi
               Delta[[r]] = listPar$delta
            }
         }

         if(updater$latentLoadingOrderSwap>0 && (iter %% updater$latentLoadingOrderSwap == 0)){
            for(r in seq_len(nr)){
               if(hM$rL[[r]]$progShrinkType=="MGP"){
                  listPar = updateLatentLoadingOrder(eta=Eta[[r]],alpha=Alpha[[r]],
                                                     lambdaTilde=LambdaTilde[[r]],lambda=Lambda[[r]],
                                                     delta=Delta[[r]],varphi=Varphi[[r]],
                                                     betaLatent=BetaLatent[[r]],gammaLatent=GammaLatent[[r]],
                                                     rhoLatent=rhoLatent[[r]], rL=hM$rL[[r]])
                  Eta[[r]] = listPar$eta
                  Alpha[[r]] = listPar$alpha
                  LambdaTilde[[r]] = listPar$lambdaTilde
                  Lambda[[r]] = listPar$lambda
                  Delta[[r]] = listPar$delta
                  Varphi[[r]] = listPar$varphi
                  BetaLatent[[r]] = listPar$betaLatent
                  GammaLatent[[r]] = listPar$gammaLatent
                  rhoLatent[[r]] = listPar$rhoLatent
               }
            }
            PsiDeltaList = updateLambdaContPriors(LambdaTilde=LambdaTilde,Delta=Delta,Vartheta=Vartheta, rL=hM$rL)
            Psi = PsiDeltaList$Psi
            Delta = PsiDeltaList$Delta
         }

         if((iter>transient) && ((iter-transient) %% thin == 0)){
            postList[[(iter-transient)/thin]] = combineParameters(Beta=Beta,BetaSel=BetaSel,wRRR = wRRR, Gamma=Gamma,iV=iV,rho=rho,iSigma=iSigma,
               Eta=Eta,Alpha=Alpha,LambdaTilde=LambdaTilde,Lambda=Lambda,Psi=Psi,Delta=Delta,
               Vartheta=Vartheta,Varphi=Varphi,W=W,BetaLatent=BetaLatent,GammaLatent=GammaLatent,rhoLatent=rhoLatent,
               PsiRRR=PsiRRR,DeltaRRR=DeltaRRR,
               ncNRRR=hM$ncNRRR, ncRRR=hM$ncRRR, ncsel = hM$ncsel, XSelect = hM$XSelect,
               XScalePar=hM$XScalePar, XInterceptInd=hM$XInterceptInd, XRRRScalePar=hM$XRRRScalePar,
               nt=hM$nt, TrScalePar=hM$TrScalePar, TrInterceptInd=hM$TrInterceptInd, rhopw=rhopw)
         }

         if((verbose > 0) && (iter%%verbose == 0)){
            if(iter > transient){
               samplingStatusString = "sampling"
            } else{
               samplingStatusString = "transient"
            }
            cat(sprintf("Chain %d, iteration %d of %d (%s)\n", chain, iter, transient+samples*thin, samplingStatusString) )
         }
      }
      return(postList)
   }

   if(nParallel > 1){
      cl = makeCluster(nParallel)
      clusterExport(cl, c("hM","nChains","indChains","transient","samples","thin","verbose","adaptNf","initSeed","initPar","updater",
         "X1", "Tr", "Y", "distr", "Pi", "C", "nr",
         "mGamma", "iUGamma", "V0", "f0", "aSigma", "bSigma", "rhopw",
         "phyloPar", "rLPar"), envir=environment())

      clusterEvalQ(cl, {
         library(BayesLogit);
         library(MCMCpack);
         library(truncnorm);
         library(Matrix);
         library(abind);
         library(Hmsc)})
      hM$postList = clusterApplyLB(cl, indChains, fun=sampleChain)
      stopCluster(cl)
   } else {
      hM$postList = vector("list", nChains)
      for(chain in indChains){
         if (fromPrior){
            postList = vector("list", samples)
            for (iter in 1:samples){
               postList[[iter]] = samplePrior(hM, dataParList=dataParList)
            }
            hM$postList[[chain]] = postList
         } else {
            hM$postList[[chain]] = sampleChain(chain)
         }
      }
   }

   hM$samples = samples
   hM$transient = transient
   hM$thin = thin
   hM$verbose = verbose
   hM$adaptNf = adaptNf
   if(alignPost && !identical(1:nChains,indChains)){
      warning('alignPost is set to FALSE as only part of chains is computed by this call', immediate.=TRUE)
      alignPost = FALSE
   }
   if(alignPost){
      for(i in 1:5){
         hM = alignPosterior(hM)
      }
   }
   return(hM)
}
